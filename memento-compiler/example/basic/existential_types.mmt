data Lazy<auto> {
  fn mk_consumer<T, U>(
    consumer: fn (x : U) -> T,
    content: U
  ) -> Lazy<T>,
};


fn force<T>(lazy: Lazy<T>) -> T {
  switch (lazy) {
    case (mk_consumer(consumer, x)) -> consumer(x)
  }
};

fn mk_lazy<T>(content: T) -> Lazy<T> {
  mk_consumer(fn (x) -> x, content)
};

fn map_lazy<T, U>(f: fn (x: T) -> U, lazy: Lazy<T>) -> Lazy<U> {
  switch (lazy) {
    case (mk_consumer(consumer, x)) -> mk_consumer(fn (y) -> f(consumer(y)), x)
  }
};

fn main() -> bool {
  let lazyValue = mk_lazy(42);
  let isLazy42 = map_lazy(fn (x) -> x == 42, lazyValue);
  force(isLazy42)
};


data TypedAST<auto> {
  fn mk_int_lit(value: int) -> TypedAST<int>,
  fn mk_add(left: TypedAST<int>, right: TypedAST<int>) -> TypedAST<int>,
  fn mk_eq<T>(left: TypedAST<int>, right: TypedAST<int>) -> TypedAST<bool>,
  fn mk_if<T>(cond: TypedAST<bool>, then_branch: TypedAST<T>, else_branch: TypedAST<T>) -> TypedAST<T>,
};

fn eval<T>(ast: TypedAST<T>) -> T {
  switch (ast) {
    case (mk_int_lit(value)) -> value,
    case (mk_add(left, right)) -> eval(left) + eval(right),
    case (mk_eq(left, right)) -> eval(left) == eval(right),
    case (mk_if(cond, then_branch, else_branch)) ->
      if(eval(cond)){ eval(then_branch) } else { eval(else_branch) }
  }
};
